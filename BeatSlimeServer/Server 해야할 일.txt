같은 객체를 다루는 코드는 한 곳에 몰아놓자 

* 텔레포트, 인던 치트키

메뉴
파티
	꼭 파티가 있어야 게임을 할 수 있나?
	매치 매이킹 시스템도 같이 필요할 것같다.
	03.23
	구현하기위해 필요한 것들
	1. 클라에서 다른 플레이어에게 파티 신청 패킷
		
	
		-> 자 여러분 파티는 보이는 친구들 한테만 보내기로 했어요
		아래 내용은 그냥 고민의 흔적이에요
			- 파티 신청은 필드에서만 가능해야됨
			- 파티 신청 가능 플레이어 목록을 만들어야됨
				- 가장 가까운 거리 순으로 쭉 나열 -> 이 방법은 파티원의 역할을 고려하지 못함 -> 역할(스킬 타입으로 유추)도 고려하고, 거리도 고려해서
				- 인던에 들어간 플레이어, 파티가 있는 플레이어는 목록에 뜨지 않음
				목록 만들기
				- Server Net클래스에는 모든 플레이어가 있다
				 플레이어의 인던 입장 유무는 cur_room_num로 구분 할 수 있다.
				 거리를 알아낼 수 있지만 플레이어 목록을 넘겨주는건 다른 문제인거 같은데
					-> 가까운 플레이어 목록을 만들고 해당 목록을 계속해서 이어가야됨
						- 이름과 인덱스 10개를 보내고
						- 가장 먼 거리 저장 후 해당 패킷 로직 종료
						- 신청을 보내거나 파티 창을 닫으면 가장 먼 거리 저장한 변수를 초기화
						더 좋은 방법없나?
						Net클래스에 PartySystem이라는 클래스가 있고 PartySystem에서 플레이어를 찾아준다. 10명씩
			PartySystem
			- Net클래스의 Client에 접근 가능 ->어짜피 싱글 톤이라 그냥 접근 가능하긴함
			- 호출을 하면 현재 플레이어 위치에서 가까운 위치의 플레이어의 목록을 보내준다.
			- 플레이어가 사용 중인 PartySystem에는 접근할 수 없다.?
			이 방법이 장점이 뭐가 있지?
			- 코드가 좀 분리 되겠네
			- Net이랑 연결되는건 어쩔 수 없나? -> 잘 모르겠다.


		- 클릭하면 해당 플레이어에게 파티 신청 

	
	2. 서버에서 파티 신청 패킷을 받고 해당 플레이어에게 파티 신청 패킷
		- 서로 다른 파티원에게 파티 신청이 왔다면?
			-> 둘다 수락을 했다

	4. 수락이면 서버에서 플레이어의 파티원 목록에 추가
		- 만약 파티 신청이 여러 개가 와서 파티원 목록이 가득 찼다면?
		- 다른 파티원에게도 파티원이 추가된 것을 알려줘야함
		- 서로 다른 클라이언트에게 파티 신청이 온걸 둘 다 수락을 한 경우 -> 먼저 온 사람과 파티가 시작되도록
		- 파티 신청자도 여러명의 클라이언트에게 요청을 보냈음 -> 먼저 수락한 사람과 파티가 시작되도록

		* 파티원 목록을 동기화하던가 -> 이걸로 하자 그냥 -> 파티 클래스라는게 따로 할 일이 없어보인다.
		클라에서 패킷이 오면 파티를 만들거나 파티에서 나가거나한다.
		클라가 접속이 종료할 때 파티에 있었으면 파티에서 나간다.
		각 Client클래스에 PartyLock이 있으니까 이걸로 임계영역 정하고 하자 락 없이는 너무 잔 버그가 많이 생길거 같다.
		이 두 상황을 제거하면 파티목록에 접근할 일은 없다.


		
	5. 거절이면 거절 패킷을 전송함
		- 단순 구현	
	- 이제 id말고 닉네임을 사용할 때가 됐다.


	-03.27
	현재 상태
	- 클라에서 파티 신청을 보내면 그대로 상대방에게 전달만 함
		* 자기자신에게 보내면 서버가 죽는 버그가 있음 -> 해결
	구현해야할 사항
	1. 클라이언트가 접속을 종료했을 경우
		- 파티원이 있으면 파티원들한테 접속 종료 패킷을 보낸다.
	2. 수락했으면 플레이어의 파티원 목록에 추가한다.

	3. 거절이면 거절 패킷을 전송한다.

	4. 속해있던 파티에서 나가고 싶은 경우 클라에서 요청을 하고 그걸 다시 다른 파티원들에게 알려줘야 한다.

	멀티스레드 고려해서 잘 만들어보자

	04.07
	현재 상태
	본인 혹은 상대방 파티의 유무에 상관 없이 요청을 보내면 파티가 되는거 같음 일단 모든 경우의 수를 적어본다음 그 부분을 처리했는지 확인해보자
	내가 파티 요청을 상대방에게 보내는 경우
	1. 나도 파티가 없고 상대방도 파티가 없고
		- 새로운 파티를 파티 풀에서 꺼내서 플레이어들에게 지정한다.
	2. 나는 파티가 있고 상대방은 파티가 없고
		- 내 파티에 상대방을 추가한다.
	3. 나는 파티가 없고 상대방은 파티가 있고
		- 파티가 있는 사람에게는 파티요청을 보낼 수 없다.
	4. 나도 파티가 있고 상대방도 파티가 있고
		- 파티가 있는 사람에게는 파티요청을 보낼 수 없다.
채팅
	구현하기위해 필요한 것
	- 클라에서 채팅을 관리할 클래스
	- 서버는 단순히 채팅을 다른 클라이언트들에게 뿌려주기만 하면됨
		-> 내용을 기억할 필요가 없그든요포탈
	2개만 있으면 될 것 같기도 하다.


판정
	03.19
	판정을 클라이언트에서하자
	현재 의견
	- 서버의 딜레이, 네트워크 상태에 상관없이 리듬을 맞추고 움직여야 리듬 게임이다.
	- 서버의 상태에 따라 달라지면 너무 이상하다
	내 생각
	- 리듬 게임인걸 망각했다. 너무 동기화에만 신경을 썼다 자 서버 딜레이, 네트워크 상태에 상관없이 리듬을 맞추고 움직인다고 생각해보자 가능한가? 
		
	- 클라에서 리듬을 맞추고 통보만 한다면 피격 판정이 올바르게 될 수 있는건가?
		가정을 해보자 
		- 만약 서버가 할 일이 많아 로직에 딜레이가 생기기 시작했다.
		- 이미 클라이언트에서는 해당 이펙트가 모두 보이고 패링 패킷까지 보냈지만 아직 서버는 처리하지 못했다
		- 현재 서버에서는 클라의 이동만 관리하고 있으므로 클라에서는 이동만 느리게 되고 게임은 계속 진행 중이다.
		 하지만 서버는 딜레이가 계속 생기므로 게임시간을 따라가지 못하고 있다 -> 패턴을 제대로 준비하지 못하고 피격 판정이 느려진다.
			클라는 계속 게임이 진행되고 서버는 늦춰지고 있는 상태가 된다.
			이펙트는 제시간에 보이지만 피격은 늦게 되는 상태가 된다.
		-> 결국 게임시간을 서버와 클라가 맞춰 줘야 한다.
		
		다른 가정(03.20)
		- 서버 딜레이는 무조건 생기는디 이건 어째해결할텨? 조금씩 계속 누적되는 딜레이가 생길것이다. 이걸 해결할 방법을 고민해보자
		 하지만 게임시간을 맞춰주면 결국 리듬을 바꾸게 되는 것이다.
		


	지금 상태
	- 클라이언트에서 PlaySound에 생기는 딜레이를 생각 못해서 판정 오차가 있었다.
	- 이 부분을 서버에 적용하지 못해 패링 비트가 틀어져 서버에 있던 패링 판정을 클라로 가져왔다.

	하지만 PlaySound에 생기는 딜레이는 클라이언트에서만 적용하고 있다. 즉 서버에는 적용되지 않고 있는 것이다. 모든 패턴 피격이 밀릴 수 밖에 없어진다.
	이걸 해결하려면 각 클라에 생기는 딜레이를 서버에 알려줘야 하고 각 클라의 플레이어마다 적용시켜서 해야한다.
	아니지 클라에서 빼고 시작하는거지 맞춰진거지
	빼고 시작했는데 서버에는 적용이 안되니 패링이 안 맞았던거고 그래서 패링을 빼고 넘겼고
	** 잘못 판단한 부분이다.
	** 클라에서는 서버보다 늦게 시작한 게임 시간을 따라가기만 하면 되기 때문에 저런 딜레이는 서버와 상관이 없다.
	** 그냥 단순이 서버의 딜레이 때문에 음악과 패턴의 진행 속도를 늦추면 안되기 때문에 클라이언트로 가져온 것이다.
타이머 큐
	- 포인터를 담는 걸로 바꿀까? 이점이 뭐가 있을까 생각해보자
패턴
	패턴을 이벤트로 등록해서 사용하기 때문에 게임 중 딜레이를 줄이려면 이 부분을 잘 만들어야됨
	** 보스는 공격하고 바로 이동 금지!! 피격관련된 문제임
	- (22.03.04)현재 상태
		
		- 게임이 시작하면 모든 패턴을 이벤트에 등록함
		- 문제점
			- 플레이어가 모두 죽을 경우 의미없는 이벤트가 계속 발생
			- 플레이어가 중간에 나갈 경우 의미없는 이벤트가 계속 발생
			- 모든 플레이어가 나갈 경우 오류 발생
		- 해결 방법
			- 게임 룸마다 현재 패턴 진행사항을 저장해 한 개의 패턴이 완료되면 그 다음 패턴을 이벤트로 등록하도록 한다.
				- timer thread말고 worker thread에서 이벤트를 등록하자 priority_queue::push가 log n의 시간이 걸릴 테니
			- 예상되는 문제점
				- 단일 블록 공격 패턴의 경우 같은 시간에 저장될 수 있는데, 게임 룸이 많아지면 딜레이가 생길 것이다. 
					-> 같은 시간에 있는 패턴은 합쳐서 진행할 수 없을까?
					-> 만약 같은 시간에 있는 패턴을 합친다면 이벤트 간 최소 간격은 bpm에 따라 결정 될 것이다.
				
				- 패턴간의 시간 텀이 짧으면 한 개의 패턴이 완료되기 전에 그 다음 패턴을 이벤트로 등록해야될 것이다.
					-> 이벤트 큐에서 꺼내자 마자 바로 다음 이벤트를 등록하자
	- (22.03.08)
		- 패링 패턴이 가끔씩 박자가 밀림
			- 비트 표시기의 경우 클라이언트에서 자체적으로 읽어서 표시함
			 즉 서버 클라이언트의 게임 시작시간이 다르면 밀릴 수 있다.
			 
		**아래의 문제를 해결하면 동시에 해결될 문제라고 생각( 이펙트와 피격을 맞추기 위해 서버와 클라이언트간의 게임 플레이 타임의 동기화가 필요할 것이기 때문)
		
		- (03.12)기존 서버에서 패턴의 시작시간과 피격결과를 알려주던 걸 클라이언트에서 패턴 시작시간을 파일에서 읽어와 이펙트를 출력하고 서버에서는 피격판정만 하도록하자
			- 이렇게 하는 이유
				-> 패턴의 시작시간은 비쥬얼을 보여줘 플레이어가 피할 수 있도록 하는 것이 목표이다. 즉 비쥬얼이 필요없는 서버에서는 굳이 처리할 필요가 없는 동작인 것이다.
			- 구현하기 위해 필요한 것들
				- 서버와 클라이언트 인 게임 플레이 시간 동기화 
					- server에서 game_start패킷을 보낼 때 현재 서버시간도 같이 보낸다 -> 인게임 클라이언트들이 같은 서버 start time을 알게 된다. -> 클라 머신에서의 system시간과 비교해 각 머신에서 시작 시간..
					- 하지만 start time을 알게 됐다 한들 뭐 할 수 있는게 없음 이 정보를 가지고 음악 재생 위치를 옮겨야 하고 패턴 이펙트를 올바른 시간에 출력해야함
					- 그렇게 하려면 서버에서 계속 경과시간을 보내야함
				- 클라이언트에서 패턴 파일 읽고 이펙트 출력
				- 서버의 패턴 시작시간 이벤트 삭제
			- 예상되는 문제점
				- 클라이언트가 중간에 나간다면? 죽는다면? 해당 클라이언트의 플레이어를 공격하는 패턴의 경우는 어떤 방식으로 처리해야 할까?
				     -> 인 게임에 있는 모든 클라이언트는 다른 클라이언트가 나가거나 죽으면 알 수 있다.
					이 맵에서 체력이 제일 많거나 적은 플레이어를 알 수 있다.
					이런 정보들은 클라이언트를 해킹하지 않는 이상 서버와 클라가 같은 값을 찾을 수 있도록 해줄 것이다. 
					만약 클라이언트를 해킹해 패턴을 바꾼다고 해도 피격판정은 서버에서 처리하기 때문에 자신만 손해를 보게 될 것이다.
					? 하지만 해킹의 목적이 그냥 게임 클리어라면? -> 패턴을 모두 알고있기 때문에 매크로를 만들 수 있음 -> 이건 모든 리듬게임에 포함되는 문제아닌가?
						- 패턴의 시작시간을 알려준다해도 매크로를 사용하면 모든 공격을 피할 수 있긴함
						* 이 문제는 로직의 문제가 아니라 리듬게임의 문제가 아닐까 생각, 다음에 다시 생각해보자
				- 서버가 느려지면 모든 클라이언트가 다 느려져야하는건가? 리듬게임인데?
					- 서버 안 느려지게 만들면 되지 클라가 느려지면.. 생각해보자
				- ...해보자
			
스킬
	스킬 레벨에 따라...

DB
	...

스크립트
	lua를 사용해 각 패턴 타입에 맞는 공격 함수 호출


클라이언트
	- (22.03.11)플레이어
		- 게임이 시작한 플레이어는 remove되야함 해결할 것
	-  (22.03.14)서버는 이미 게임을 시작했고 패킷을 받고 뒤늦게 시작하는 클라가 서버의 시작시간을 따라가야 한다.
           클라에서 생기는 지연시간
           	- 패킷 오가는 시간
            	- ping 패킷을 이용해 최근 주고받은 핑10개의 평균을 낸 시간을 구할 수 있도록 만든다.
          	- 게임 start 패킷을 받고 PlaySound를 할 때 걸리는 시간
            	- offsetTimed이라는 변수에 PlaySound를 할 때 걸리는 시간을 계산한다.

	- 22.03.15) 문제점
		- 장판을 못피함
			- 클라에서 눈으로 보여지는 이펙트와 서버에서 피격 판정을 하는 시간이 안 맞는 이유 뿐이겠지
			- peekpattern이 제시간에 잘 동작하는가? -> update가 fixed라 제 시간동작이 어렵겠는걸? -> 아닌걸?
				눈에 보이는 위치는 피해졌음 -> 서버에서의 플레이어 좌표 이동도 완료된 상태라는 뜻
				장판이 커지는 크기와 플레이어가 피격되는 시간은 동일함 
					
			- (03.16)원인 발견 및 해결
				- 서버에서 피격판정을 할 때 클라이언트의 위치를 읽어서 판정을 함, 이펙트를 보고 피했는데 피격판정은 피한 클라이언트의 위치를 가지고 하는 상황
				 이걸 해결하기 위해 플레이어에게 prePos를 추가해 이펙트의 speed시간 이전에 이동한 적이 있으면 그 위치를 기준으로 피격 판정을 하도록 만들었다.
				 이펙트의 speed는 리듬게임이기 때문에 리듬에 맞춰서 결정된다.

			
            	ping 평균과 offsetTimed을 nowSongTime에 더하여 현재 패턴의 진행 사항을 조정한다.
         	 ** 음악의 재생위치도 조정해야할까?
	// 게임 시작시간만 알고있으면 경과시간은 필요 없다고 판단됨
        // 서버가 렉이 걸린다해도 경과시간(시스템시간)은 일정하게 지나갈것이고 그건 클라이언트에서 시간을 측정해도 똑같은 결과를 얻을 수 있음
        // 서버의 렉을 판정하려면 ping test패킷을 보내 패킷을 다시 받는데 걸리는 시간을 측정해 딜레이 시간을 계산하는 것이 옳은 방법이라 생각
	
	-(03.17) 게임 종료 판정 기준 변경
		- 플레이어가 죽으면 다른 아이디를 찾아 패턴을 넘겨주던 방식이 게임성을 해친다고 판단 -> 한 명이 죽으면 너무 어려워지고 패링 패턴이 곂칠 수 있음
		- 한 명이라도 죽거나 종료하면 인던을 끝내기로함 -> 힐 캐릭터 역할의 중요성 증가
		
		구현하기 위해 필요한 것들
			- 서버의 disconnect_client함수를 이용해 종료한 플레이어를 찾는다.
			- 피격 판정, 패링 공격 성공 여부를 판단할 때 체력이 감소되고 이 때 죽는 플레이어를 찾아 한 명이라도 죽으면 pattern을 등록하지 말고 게임 end패킷을 보낸다.
			- 한 명이 나간경우, 죽은 경우, 보스를 죽여서 게임이 끝난 경우, 음악 시간이 다되서 게임이 끝난 경우를 나눠서 판단한다.

		예상되는 문제점
			- 없음


플레이어 충돌
	* 인던으로 들어갈때 기존 필드 위치 정리해두고 들어가자
	- (03.19)더미 클라이언트를 만들기 위해 일단 플레이어 충돌을 구현해 시야에 보이는 플레이어의 수를 줄이기로 했음
	- 구현해야할 사항
		- 멀티 스레드에서 안전하게 돌아갈 플레이어들 위치를 저장한 자료구조
	- map에 플레이어의 위치까지 표시하는건 어떨까
		-> 각 인던은 mapinfo에서 맵 정보를 받아와 충돌 체크를 하기때문에 map에 플레이어의 위치까지 표시하지 못할 것 같다.
		-> 새로운 자료구조가 필요
		-> game_room 자료구조마다 map을 가지고 있어야겠다. 그런데 굳이 이걸 나눴어야 됐을까?
		-> 겨우 플레이어 3명 충돌 처리하려고 인던마다 맵을 가지는건 아닌거 같음 캐시도 그렇고 포인터 연산은 캐시랑 관련이 없나?

	구현
	- 이동은 리듬게임이기 때문에 속도에 제한이 있다. 인던에 플레이어는 3명뿐이다. 인던에서는 3명과 충돌을 했는지만 판단하자
	- 필드에서는 같은 map을 사용하니 이걸 이용해 충돌 검사를하자 atomic int 배열로 하면 되나? 잘 모르겠다 이부분은 질문을 해보는게; 좋겠다 정리해보자
		-> 어짜피 메모리에 쓰이는 값은 1아님 0이다 이게 다중 스레드를 사용해 잘린다 해도 0아님 1인거다 우리 게임에서 필드 내에서 충돌이 크게 중요한가?
		  크게 안중요하니 그냥 int로 해보고 그뒤에 수정하자



길찾기
	* 요구사항 : 클라이언트에서 선택한 셀로 플레이어를 이동시키자
	* 없는 길을 찾으라하면 터짐 아 에이스타 시간이 길어지면서 그러는거군 step을 추가시키자
	구현해야할 사항
	- 서버 a*알고리즘
	- 클라에서 선택한 위치 패킷으로 전송
	고려 사항
	- a*를 사용해 이동하고 있을 때 이동을 하면 a* 종료
	- 이동 중 set pos패킷이 오면 목적지 변경
	- 이동 중 move 패킷이 오면 a*종료
	a* 종료는 dest가 -1이면 바로 종료하자


