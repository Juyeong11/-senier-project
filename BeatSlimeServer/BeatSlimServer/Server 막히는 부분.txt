
오브젝트 자료구조
현재 상황
	플레이어를 클라이언트에 그려야한다. (플레이어는 마을 존, 레이드 존으로 나뉜다.)
	플레이어의 업데이트는 서버에서 보내주는 패킷을 보고 해당 플레이어를 업데이트한다.
	마을에 있는 플레이어 따로 레이드 존에 있는 플레이어 따로 그려야 할 것이다.
생각한 방법
	그러면 서버에서 보내주는 패킷을 보고 해당되는 플레이어를 빨리 찾아야한다. -> 배열, 맵, hash
	위의 자료구조를 사용하려면 데이터의 삽입이 자주 발생하면 안된다 
		-> 미리 최대 접속 클라이언트 수 만큼 만들어 둘까? -> 일단 이 방법으로 하자
		-> stl의 벡터처럼 처음 삽입 요청이 오고 컨테이너가 꽉 찼으면 적당한 배수만큼의 크기로 다시 만드는 방법은?
		-> 배열로하고 삽입으로 인한 데이터 이동을 줄이기 위해 미리 공간을 만들어 두자 

	다른 존에 있는 플레이어는 다른 컨테이너에 들어가 있겠지?
		레이드 존은 5명
		마을 존은 N명
	마을과 레이드 존 사이의 이동은 계속 있을 것이고



타이밍
현재 상황
	클라이언트에서 음악 타이밍을 맞추고 있다. 서버에서 타이밍이 맞다면 움직이도록 하고 싶다.
	서버에서 타이밍을 계산해 클라이언트에게 움직이라고 명령을 주면
생각한 방법
	방법 1	
	게임이 시작하면 음악의 길이, bpm을 전송하고 음악이 얼마만큼 재생되었는지를 계산 시작한다.
		-> 이런 방법으로하면 클라이언트에서 타이밍을 계산해 리듬에 맞은 경우에만 이동 패킷을 보낸 형식이 된다.
		-> 만약 해킹된다면 플레이어는 마음대로 움직일 수 있을 것이다.

	방법 2
	클라이언트는 아무것도 모른다. 키 입력만 전송할 뿐		
	이동 방법
		CS-> 움직인다고 알린다.()
		SC-> 서버가 계산하고 있는 이동 타이밍에 맞았다면 움직이고 패킷을 보낸다.
	타이밍에 맞지 않은 패킷이 계속 전송되면서 네트워크 낭비가 있다.
		클라이언트에서 bpm을 알고 거기서 계산한 박자에 맞춰 일정 시간동안만 한 번씩만 패킷을 보내는게 허용된다면? 
		해킹된다해도 네트워크를 낭비하는 것 -> 
	
	방법 3
	클라이언트는 아무것도 모르지만 서버에서 이동하라고 전송이 오면 무조건 움직인다.
	이동 방법
		SC-> 지금부터 ??ms동안 움직일 수 있다!
		CS-> 이동키가 시간내에 입력 되면 이동 패킷 전송!
		SC-> 서버에서 정말 해당 시간에 입력된건지 확인하고 이동 패킷 전송
	타이밍에 맞지않은 패킷이 계속 전송되는 것보다 네트워크 사용량이 적은가? -> 2번 방법에서 키를 막 누르는 것이 아니라면 해당 방법이 무조건 더 많을 것

업데이트
현재 상황
	메인 루프에서 update를 실행한다.
생각한 방법
	