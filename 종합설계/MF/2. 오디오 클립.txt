WMV 파일에서 오디오 클립 추출

------------------------------------------
IMFSourceReader 인터페이스 함수

Flush

GetCurrentMediaType

GetNativeMediaType

GetPresentationAttribute

GetServiceForStream

GetStreamSelection

ReadSample

SetCurrentMediaType

SetCurrentPosition

SetStreamSelection

------------------------------------------
HRESULT CoInitializeEx( 
  LPVOID prReserved, 
  DWORD dwCoInit
);
 COM 라이브러리 초기화 함수

MFStartup( 
  ULONG Version, 
  DWORD dwFlags
)
 dwFlags-> SOCKET하고 관련이 있는거 같음 네트워크에서 사용하는게 소켓아닌가?

HRESULT MFCreateSourceReaderFromURL(
  LPCWSTR         pwszURL, 		->열려고 하는 미디어 파일의 URL
  IMFAttributes   *pAttributes,	->이 매개변수를 사용하여 소스 판독기(==소스 리더)를 구성할 수 있음
  IMFSourceReader **ppSourceReader
);

IMFMediaType <- IMFAttributes
 미디어 형식에 대한 설명을 나타낸다

HRESULT MFCreateMediaType(
  IMFMediaType **ppMFType
);
빈 미디어 유형을 만듭니다.

----------------------------------------------------
미디어 파일(Source)에서 압축되지않은 오디오 스트림을 뽑아내는 방법

1. 오디오 스트림을 설정 (샘플에서 ConfigureAudioStream함수)

	1-1. MFCreateMediaType을 이용해 미디어 타입을 만든다.

	1-2. IMFAttributes::SetGUID함수를 이용해 미디어 타입을 정의 한다.
		HRESULT SetGUID(
		 REFGUID guidKey, -> 아래 Value에 맞는 키를 적어주면된다. Value가 미디어 타입일 경우 주로 MF_MT_MAJOR_TYPE 사용
		 REFGUID guidValue -> MFMediaType_Audio,Video, Stream등 다양한 타입이 있고
		);
		각 타입 마다 하위 유형이 있다 오디오의 경우는 MFAudioFormat_MP3, PCM, AAC.. 등 이 있고 알맞는 하위 유형을 정해주면 될듯?

		    if (SUCCEEDED(hr))
		    {
		        hr = pPartialType->SetGUID(MF_MT_MAJOR_TYPE, MFMediaType_Audio);
		    }

		    if (SUCCEEDED(hr))
		    {
		        hr = pPartialType->SetGUID(MF_MT_SUBTYPE, MFAudioFormat_PCM);
		    }
		이런식으로 된다.
		

	1-3. IMFSourceReader::SetCurrentMediaType()을 이용해 정의해준 미디어 타입을 소스 리더에 설정한다.
		HRESULT SetCurrentMediaType(
		  DWORD        dwStreamIndex, -> 0~0xFFFFFFFB or MF_SOURCE_READER_FIRST_VIDEO_STREAM, MF_SOURCE_READER_FIRST_AUDIO_STREAM을 인자로 넣을 수 있다
		  DWORD        *pdwReserved,  -> 생략되고 NULL값이 들어감
		  IMFMediaType *pMediaType  -> 위에서 정의해준 미디어 타입
		);

	1-4 IMFSourceReader::GetCurrentMediaType()을 이용해 소스리더의 스트림의 현재 미디어 유형을 pUncompressedAudioType변수에 가지고 옵니다.

	1-5. IMFSourceReader::SetStreamSelection()을 이용해 스트림을 선택한다.
		HRESULT SetStreamSelection(
		  DWORD dwStreamIndex, -> 0~0xFFFFFFFB or MF_SOURCE_READER_FIRST_VIDEO_STREAM, MF_SOURCE_READER_FIRST_AUDIO_STREAM을 인자로 넣을 수 있다
		  BOOL  fSelected -> 스트림을 선택하려면 TRUE 스트림 선택을 취소하려면 FALSE
		);
		* 일부 미디어 파일에는 동일한 유형의 여러 스트림이 포함되어 있습니다. 예를 들어 파일에 여러 언어에 대한 오디오 스트림이 포함될 수 있습니다. 이 방법을 사용하여 선택한 스트림을 변경할 수 있습니다. 각 스트림에 대한 정보를 얻으려면 IMFSourceReader::GetPresentationAttribute 또는 IMFSourceReader::GetNativeMediaType 을 호출하십시오 .
		* 스트림 중 하나의 데이터가 필요하지 않은 경우 해당 스트림을 선택 해제하는 것이 좋습니다. 스트림을 선택하면 미디어 소스가 읽지 않은 데이터의 대기열을 유지하고 대기열이 무한정 커져 메모리를 소모할 수 있습니다.

	1-6. 얻어온 오디오 타입을 대입해주고 끝

	        *ppPCMAudio = pUncompressedAudioType; -> Set해줄 때 사용했던 변수로 하면 동작 안함 Set할 때 변수랑 Get할 변수가 따로 필요한듯
	        (*ppPCMAudio)->AddRef();


2. 출력할 오디오 파일의 헤더를 적는다.(WriteWaveHeader) -> 미디어 유형에 따라 다르게 설정하면 다른 출력결과를 얻을 수 있을 것 같다.

	2-1. WAVEFORMATEX 파형 오디오 데이터의 포맷을 정의한다. (MFCreateWaveFormatExFromMFMediaType 함수 사용)
		모든 오디오 데이터 형식에 공통적인 형식 정보만 이 구조에 포함됩니다.
		typedef struct tWAVEFORMATEX {
		  WORD  wFormatTag;
		  WORD  nChannels;
		  DWORD nSamplesPerSec;
		  DWORD nAvgBytesPerSec;
		  WORD  nBlockAlign;
		  WORD  wBitsPerSample;
		  WORD  cbSize;
		} WAVEFORMATEX, *PWAVEFORMATEX, *NPWAVEFORMATEX, *LPWAVEFORMATEX;
		
		
		HRESULT MFCreateWaveFormatExFromMFMediaType( Media Foundation오디오 미디어 유형을 위의 WAVEFORMATEX 구조로 변환합니다.
		  IMFMediaType *pMFType,
		  WAVEFORMATEX **ppWF,
		  UINT32       *pcbSize,
		  UINT32       Flags //생략
		);
	

`	2-2 RIFF헤더를 만들고 fmt Chunk를 시작한다
		wave파일은 크게 3개의 파트로 구성되어있다 -> RIFF(미디어 재생을 위해 마이크로소프트가 만든 내부데이터 포맷), FMT(샘플당 바이트수, 채널같은 정보들), DATA(PCM데이터 실제 음원)이다
	
		WriteFile함수를 이용해 정의 해준 헤더를 적어 주고 헤더의 크기를 정한다.


3. 디코딩할 최대 오디오 양을 바이트 단위로 계산합니다.
	
	3-1 오디오 블럭크기와 bytes/second의 수를 오디오 포맷으로 부터 구합니다.
		UINT32 MFGetAttributeUINT32( //guidkey에 해당하는 값이 pAttributes에 있는 속성인 경우 반환해 줍니다.
		  IMFAttributes *pAttributes, -> 앞서 정의했던 미디어 타입을 넣습니다.
		  REFGUID       guidKey,	-> GUID상수로 어떤 것을 구할지 넣어줍니다. MF_MT_AUDIO_BLOCK_ALIGNMENT(해당 유형의 따른 한 블록 크기?) MF_MT_AUDIO_AVG_BYTES_PER_SECOND(해당 유형의 초당 평균 바이트 수)
		  UINT32        unDefault
		);

	3-2 구한 초당 바이트수를 가지고 오디오클립의 사이즈를 구합니다.
		int MulDiv( //두 개의 32비트 값을 곱한 다음 64비트 결과를 세 번째 32비트 값으로 나눕니다. 최종 결과는 가장 가까운 정수로 반올림됩니다.
		  int nNumber,
		  int nNumerator,
		  int nDenominator
		);

	3-3 구한 크기가 최대 DWORD값보다 크다면 최대 DWORD값으로 만들어 줍니다.

	3-4 부분 오디오 프레임을 쓰지 않도록 오디오 블록 크기로 반올림해줍니다. 마지막에 남은 프레임이 블록보다 작은 프레임일 경우를 막아줌



4. 소스 파일(비디오)에서 PCM오디오 데이터를 디코딩하여 WAVE파일에 씁니다.
	
	IMFSample -> 미디어 데이터의 컨테이너 개체인 미디어 샘플을 나타냅니다 비디오의 경우 샘플에는 하나의 비도 프레임이 포함됩니다.
		       오디오의 경우 샘플에는 단일 오디오 샘플이 아닌 여러 오디오 샘플이 포함됩니다.

	IMFMediaBuffer -> 미디어 샘플에는 0개 이상의 버퍼가 있습니다. 각 버퍼는 메모리 블록을 관리하며 IMFMediaBuffer 인터페이스로 표시됩니다
			버퍼는 인덱스 값으로 액세스 할 수 있습니다.

	4-1 IMFSourceReader::ReadSample을 이용해 원본에서 샘플을 읽어 옵니다.

		HRESULT ReadSample(// 미디어 소스에서 샘플을 읽습니다.
		  DWORD     dwStreamIndex, //데이터를 가져올 스트림입니다. 0~0xFFFFFFFE
		  DWORD     dwControlFlags,
		  DWORD     *pdwActualStreamIndex,
		  DWORD     *pdwStreamFlags,
		  LONGLONG  *pllTimestamp,
		  IMFSample **ppSample
		);

	4-2 IMFSourceReader::ConvertToContiguousBuffer을 이용해 여러 버퍼가 있는 샘플을 단일 버퍼로 변환합니다. -> pBuffer

	4-3 pBuffer-> IMFMediaBuffer::Lock 읽기, 쓰기를 위해 호출자에게 버퍼의 메모리에 관한 액세스 권한을 부여합니다.

		HRESULT Lock(
		  BYTE  **ppbBuffer, 	// 	버퍼시작에 대한 포인터
		  DWORD *pcbMaxLength,	//	최대 데이터양
		  DWORD *pcbCurrentLength//	버퍼에 있는 유효한 데이터 길이(byte단위)
		);

	4-3 pAudioData에 있는 데이터를 cbBuffer만큼 출력 합니다. 그 뒤 버퍼의 락을 풀어 줍니다.

	4-4 이 과정을 오디오 데이터의 크기가 지정된 최대 오디오 크기가 될때 까지 반복하여 줍니다.

5. 올바른 크기로RIFF헤더를 수정한다. -> 마지막으로 데이터 크기와 생략된 8바이트를 추가해 준다는데 아직 이해 못함 구조에 익숙해지면 이해될듯

